import { NextRequest, NextResponse } from 'next/server';
import * as fs from 'fs';
import * as path from 'path';

// Load chart data and optimized models
const chartDataPath = path.resolve(process.cwd(), 'src/app/ktc-predictor/chart-data.json');

// PFF-enhanced year-specific model paths
const PFF_MODEL_PATHS: Record<number, { xgb: string; lgb: string }> = {
  2022: {
    xgb: path.resolve(process.cwd(), 'src/app/ktc-predictor/xgboost-pff-2022.json'),
    lgb: path.resolve(process.cwd(), 'src/app/ktc-predictor/lightgbm-pff-2022.json'),
  },
  2023: {
    xgb: path.resolve(process.cwd(), 'src/app/ktc-predictor/xgboost-pff-2023.json'),
    lgb: path.resolve(process.cwd(), 'src/app/ktc-predictor/lightgbm-pff-2023.json'),
  },
  2024: {
    xgb: path.resolve(process.cwd(), 'src/app/ktc-predictor/xgboost-pff-2024.json'),
    lgb: path.resolve(process.cwd(), 'src/app/ktc-predictor/lightgbm-pff-2024.json'),
  },
  2025: {
    xgb: path.resolve(process.cwd(), 'src/app/ktc-predictor/xgboost-pff-2025.json'),
    lgb: path.resolve(process.cwd(), 'src/app/ktc-predictor/lightgbm-pff-2025.json'),
  },
  2026: {
    xgb: path.resolve(process.cwd(), 'src/app/ktc-predictor/xgboost-pff-2026.json'),
    lgb: path.resolve(process.cwd(), 'src/app/ktc-predictor/lightgbm-pff-2026.json'),
  },
};

// Legacy model paths (fallback)
const xgbModelPath = path.resolve(process.cwd(), 'src/app/ktc-predictor/xgboost-optimized.json');
const lgbModelPath = path.resolve(process.cwd(), 'src/app/ktc-predictor/lightgbm-optimized.json');

// Quantile models for uncertainty estimation
const lgbQ10ModelPath = path.resolve(process.cwd(), 'src/app/ktc-predictor/lightgbm-q10.json');
const lgbQ90ModelPath = path.resolve(process.cwd(), 'src/app/ktc-predictor/lightgbm-q90.json');

const GAMES_PER_SEASON = 17;
const KTC_MAX_VALUE = 9999;

// Age cliffs by position (same as Python model)
const AGE_CLIFFS: Record<string, number> = {
  QB: 35,
  RB: 27,
  WR: 30,
  TE: 30,
};

// Tier definitions for tier-specific models
type Tier = 'elite' | 'tier1' | 'tier2' | 'mid' | 'low';

// Hybrid approach: Use tier-specific models only where they outperform unified
// Elite: bias improved -893 → -489 (45% better)
// Tier-1: bias improved -292 → -39 (87% better)
// Low: bias improved -52 → -2 (96% better)
// Mid/Tier-2: unified model has better MAE, so use unified
const HYBRID_TIERS: Tier[] = ['elite', 'tier1', 'low'];

function detectTier(startKtc: number): Tier {
  if (startKtc >= 8000) return 'elite';
  if (startKtc >= 6000) return 'tier1';
  if (startKtc >= 4000) return 'tier2';
  if (startKtc >= 2000) return 'mid';
  return 'low';
}

// Tier-specific model paths (generated by train_tier_specific.py)
function getTierModelPaths(year: number, tier: Tier): { xgb: string; lgb: string } {
  return {
    xgb: path.resolve(process.cwd(), `src/app/ktc-predictor/xgboost-pff-${year}-${tier}.json`),
    lgb: path.resolve(process.cwd(), `src/app/ktc-predictor/lightgbm-pff-${year}-${tier}.json`),
  };
}

interface SeasonData {
  year: number;
  fantasyPoints: number;
  gamesPlayed: number;
  startKtc: number;
  actualEndKtc: number;
  predictedEndKtc: number;
}

interface PlayerChartData {
  playerId: string;
  name: string;
  position: string;
  currentAge: number;
  yearsExp: number;
  latestKtc: number;
  ktc30dTrend: number;
  ktc90dTrend: number;
  historicalSnapPct: number;
  confidenceScore: number;
  confidenceFactors: {
    dataAvailability: number;
    ageFactor: number;
    historicalAccuracy: number;
    performanceStability: number;
  };
  seasons: SeasonData[];
}

interface ChartDataOutput {
  players: PlayerChartData[];
  metadata: {
    generatedAt: string;
    totalPlayers: number;
    totalSeasons: number;
  };
}

// XGBoost tree structure
interface XGBoostTree {
  left_children: number[];
  right_children: number[];
  split_indices: number[];
  split_conditions: number[];
  base_weights: number[];
  default_left: number[];
}

interface XGBoostModel {
  learner: {
    gradient_booster: {
      model: {
        trees: XGBoostTree[];
      };
    };
    learner_model_param: {
      base_score: string;
    };
  };
}

// LightGBM tree structure
interface LightGBMNode {
  split_feature?: number;
  threshold?: number;
  decision_type?: string;
  left_child?: LightGBMNode;
  right_child?: LightGBMNode;
  leaf_value?: number;
  leaf_index?: number;
}

interface LightGBMTree {
  tree_index: number;
  shrinkage: number;
  tree_structure: LightGBMNode;
}

interface LightGBMModel {
  metadata: {
    model_type: string;
    n_features: number;
    feature_names: string[];
  };
  lightgbm_model: {
    tree_info: LightGBMTree[];
  };
}

// ============================================================================
// Feature Extraction (148 features matching Python model)
// ============================================================================

function normalizeKtc(ktc: number): number {
  return Math.min(ktc / KTC_MAX_VALUE, 1.0);
}

function normalizeAge(age: number): number {
  return Math.max(0, Math.min((age - 21) / 15, 1.0));
}

function normalizeYearsExp(yearsExp: number): number {
  return Math.min(yearsExp / 10, 1.0);
}

function normalizeFp(fp: number): number {
  return Math.min(fp / 400, 1.0);
}

function normalizeGames(games: number): number {
  return Math.min(games / 17, 1.0);
}

function normalizeFpChangeYoy(change: number | null): number {
  if (change === null) return 0.5;
  return (Math.max(-0.5, Math.min(change, 1.0)) + 0.5) / 1.5;
}

// Estimate stats from projected FP based on position
function estimateStatsFromFP(
  projectedFP: number,
  games: number,
  position: string
): {
  receptions: number;
  targets: number;
  receivingYards: number;
  receivingTds: number;
  carries: number;
  rushingYards: number;
  rushingTds: number;
  passingYards: number;
  passingTds: number;
  interceptions: number;
} {
  // PPR scoring: 1 pt per reception, 0.1 per yard, 6 per TD
  // Position-typical stat distributions based on average elite players

  if (position === 'QB') {
    // QB: ~4 pts/pass yard, ~4 pts/pass TD, ~6 pts/rush TD
    const passingYards = projectedFP * 50; // ~250 yards/game = ~12.5 PPG from passing yards
    const passingTds = Math.max(0, (projectedFP - passingYards * 0.04) / 4 * 0.7);
    const rushingYards = projectedFP * 2;
    const rushingTds = Math.max(0, (projectedFP - passingYards * 0.04 - passingTds * 4) / 6);
    const interceptions = passingTds * 0.4; // ~40% INT rate relative to TDs

    return {
      receptions: 0,
      targets: 0,
      receivingYards: 0,
      receivingTds: 0,
      carries: rushingYards / 5,
      rushingYards: Math.min(rushingYards, 600),
      rushingTds: Math.min(rushingTds, 8),
      passingYards: Math.min(passingYards, 5500),
      passingTds: Math.min(passingTds, 50),
      interceptions: Math.min(interceptions, 20),
    };
  } else if (position === 'RB') {
    // RB: Mix of rushing and receiving
    const rushingPct = 0.65; // 65% from rushing
    const rushingFP = projectedFP * rushingPct;
    const receivingFP = projectedFP * (1 - rushingPct);

    // Rushing: ~0.1 pts/yard + 6 pts/TD, avg 4.5 YPC
    const rushingYards = rushingFP * 7;
    const rushingTds = (rushingFP - rushingYards * 0.1) / 6;
    const carries = rushingYards / 4.5;

    // Receiving: 1 pt/rec + 0.1/yard + 6/TD
    const receptions = receivingFP * 0.3;
    const receivingYards = receptions * 8;
    const receivingTds = Math.max(0, (receivingFP - receptions - receivingYards * 0.1) / 6);
    const targets = receptions / 0.75;

    return {
      receptions: Math.min(receptions, 100),
      targets: Math.min(targets, 140),
      receivingYards: Math.min(receivingYards, 800),
      receivingTds: Math.min(receivingTds, 5),
      carries: Math.min(carries, 350),
      rushingYards: Math.min(rushingYards, 1800),
      rushingTds: Math.min(rushingTds, 18),
      passingYards: 0,
      passingTds: 0,
      interceptions: 0,
    };
  } else if (position === 'WR') {
    // WR: Mostly receiving
    const receptions = projectedFP * 0.35;
    const receivingYards = projectedFP * 5.5;
    const receivingTds = Math.max(0, (projectedFP - receptions - receivingYards * 0.1) / 6);
    const targets = receptions / 0.65;

    return {
      receptions: Math.min(receptions, 120),
      targets: Math.min(targets, 180),
      receivingYards: Math.min(receivingYards, 1800),
      receivingTds: Math.min(receivingTds, 15),
      carries: projectedFP * 0.01,
      rushingYards: projectedFP * 0.15,
      rushingTds: 0,
      passingYards: 0,
      passingTds: 0,
      interceptions: 0,
    };
  } else {
    // TE: Similar to WR but lower volume
    const receptions = projectedFP * 0.4;
    const receivingYards = projectedFP * 4.5;
    const receivingTds = Math.max(0, (projectedFP - receptions - receivingYards * 0.1) / 6);
    const targets = receptions / 0.68;

    return {
      receptions: Math.min(receptions, 100),
      targets: Math.min(targets, 150),
      receivingYards: Math.min(receivingYards, 1200),
      receivingTds: Math.min(receivingTds, 12),
      carries: 0,
      rushingYards: 0,
      rushingTds: 0,
      passingYards: 0,
      passingTds: 0,
      interceptions: 0,
    };
  }
}

// Extract 61 features matching the Python model
function extractEnhancedFeatures(
  startKtc: number,
  ktc30dTrend: number,
  ktc90dTrend: number,
  age: number,
  yearsExp: number,
  projectedFP: number,
  projectedGames: number,
  position: string,
  baselineFP: number,
  snapPct: number,
  rookieYear: number | null = null
): number[] {
  // Normalize inputs
  const startKtcNorm = normalizeKtc(startKtc);
  const ktc30d = Math.max(-1, Math.min(ktc30dTrend, 1));
  const ktc90d = Math.max(-1, Math.min(ktc90dTrend, 1));
  const ageFactor = normalizeAge(age);
  const yearsExpNorm = normalizeYearsExp(yearsExp);
  const fpNorm = normalizeFp(projectedFP);
  const gamesFactor = normalizeGames(projectedGames);
  const fpPerGame = (projectedFP / Math.max(projectedGames, 1)) / 25;

  // Prior year FP and change
  const priorFpNorm = normalizeFp(baselineFP);

  // Prior FP per game: estimate from baseline FP assuming typical 17 games
  // For projections, we don't have prior year games, so approximate with avg season
  const priorFpPerGame = baselineFP > 0
    ? (baselineFP / GAMES_PER_SEASON) / 25  // Same normalization as fp_per_game
    : 0.5;  // Neutral default if no prior data

  // FP per game change: current normalized fp/g - prior normalized fp/g
  // Positive = improvement, negative = decline
  const fpPerGameChange = baselineFP > 0
    ? fpPerGame - priorFpPerGame
    : 0;  // No change if no prior data

  const rawFpChange = baselineFP > 0 ? (projectedFP - baselineFP) / baselineFP : 0;
  const fpChangeYoy = normalizeFpChangeYoy(rawFpChange);

  // Position rank (estimated from FP)
  const positionRankNorm = Math.min(50, Math.max(1, 50 - projectedFP / 5)) / 50;

  // KTC volatility
  const ktcVolatility = Math.min(Math.abs(ktc30dTrend) + Math.abs(ktc90dTrend), 1.0);

  // Breakout candidate
  const isBreakoutCandidate = (yearsExp <= 2 && fpNorm > 0.3 && startKtcNorm < 0.5) ? 1 : 0;

  // Position encoding
  const isQb = position === 'QB' ? 1 : 0;
  const isRb = position === 'RB' ? 1 : 0;
  const isWr = position === 'WR' ? 1 : 0;
  const isTe = position === 'TE' ? 1 : 0;

  // Estimate stats from projected FP
  const stats = estimateStatsFromFP(projectedFP, projectedGames, position);

  // Receiving stats
  const receptionsNorm = Math.min(stats.receptions / 120, 1.0);
  const targetsNorm = Math.min(stats.targets / 180, 1.0);
  const receivingYardsNorm = Math.min(stats.receivingYards / 1800, 1.0);
  const receivingTdsNorm = Math.min(stats.receivingTds / 15, 1.0);
  const yardsPerTarget = (stats.receivingYards / Math.max(stats.targets, 1)) / 15;
  const targetShare = projectedGames > 0 ? Math.min(stats.targets / (projectedGames * 8), 1.0) : 0;

  // Rushing stats
  const carriesNorm = Math.min(stats.carries / 350, 1.0);
  const rushingYardsNorm = Math.min(stats.rushingYards / 1800, 1.0);
  const rushingTdsNorm = Math.min(stats.rushingTds / 18, 1.0);
  const yardsPerCarry = (stats.rushingYards / Math.max(stats.carries, 1)) / 6;

  // Passing stats
  const passingYardsNorm = Math.min(stats.passingYards / 5500, 1.0);
  const passingTdsNorm = Math.min(stats.passingTds / 50, 1.0);
  const interceptionsNorm = Math.min(stats.interceptions / 20, 1.0);

  // Draft (use defaults since we don't have this in projection)
  const draftRoundValue = 0.5;
  const draftPickValue = 0.5;

  // Interaction features
  const ageFpInteraction = ageFactor * fpNorm;

  // Cliff years penalty (steeper: (years/2)^1.5 to match Python)
  const cliffAge = AGE_CLIFFS[position] || 30;
  const yearsPastCliff = Math.max(0, age - cliffAge);
  const cliffYearsPenalty = yearsPastCliff > 0 ? Math.min((yearsPastCliff / 2) ** 1.5, 1.0) : 0;

  // Age-experience gap
  const ageExpGap = ((age - 21) - yearsExp) / 10;

  // Snap-based features
  const snapPctNorm = Math.min(snapPct, 1.0);
  const fpPerSnap = projectedGames > 0 ? (projectedFP / Math.max(projectedGames * snapPct * 60, 1)) / 0.5 : 0;

  // Elite youth premium
  const ageYouthFactor = Math.max(0, (28 - age) / 7);
  const eliteFactor = Math.max(0, fpNorm - 0.5);
  const eliteYouthPremium = Math.min((ageYouthFactor ** 2) * (eliteFactor ** 2) * 4, 1.0);

  // FP trajectory
  const clampedChange = Math.max(-0.5, Math.min(rawFpChange, 1.0));
  const fpTrajectory = (clampedChange + 0.5) / 1.5;

  // QB-specific features
  const qbTdIntRatio = isQb ? Math.min((stats.passingTds / Math.max(stats.interceptions, 1)) / 5, 1) : 0;
  const qbRushingBonus = isQb ? Math.min((stats.rushingYards + stats.rushingTds * 60) / 1000, 1) : 0;
  const qbAgePremium = isQb ? Math.max(0, 1 - (age - 26) / 10) : 0;
  const qbEfficiency = isQb ? Math.min(stats.passingYards / Math.max(stats.interceptions * 100, 1) / 50, 1) : 0;

  // Elite tier features
  const isEliteTier = startKtcNorm > 0.6 ? 1 : 0;
  const eliteAgeInteraction = isEliteTier * ageFactor;
  const eliteTrajectoryInteraction = isEliteTier * fpTrajectory;
  const eliteVolatilityDampener = isEliteTier * (1 - ktcVolatility);

  // Advanced features
  const efficiencyVolume = fpPerSnap * targetShare;
  const workloadIntensity = projectedGames > 0 ? Math.min((stats.carries + stats.targets) / projectedGames / 20, 1) : 0;
  const tdConversionRate = (stats.receivingTds + stats.rushingTds) / Math.max(stats.carries + stats.targets, 1);
  const trajectoryCliffInteraction = fpTrajectory * (1 - cliffYearsPenalty);
  const draftPerformanceRatio = draftRoundValue * fpNorm;

  // Decline/collapse features
  let yoyDeclineSeverity = 0;
  if (rawFpChange < 0) {
    const declineMagnitude = Math.min(Math.abs(rawFpChange) / 0.5, 1.0);
    const ageAmplifier = age >= cliffAge ? 1.5 : (age >= cliffAge - 2 ? 1.2 : 1.0);
    yoyDeclineSeverity = Math.min(declineMagnitude * ageAmplifier, 1.0);
  }

  const gamesPlayedCollapse = projectedGames < 8 ? Math.max(0, (8 - projectedGames) / 8) : 0;

  // Gap year penalty
  let gapYearPenalty = 0;
  if (projectedGames <= 4) {
    const hadPriorProduction = baselineFP > 50;
    const basePenalty = hadPriorProduction ? 0.6 : 0.3;
    const agePenalty = age >= cliffAge ? 0.4 : (age >= cliffAge - 2 ? 0.2 : 0);
    gapYearPenalty = Math.min(basePenalty + agePenalty, 1.0);
  }

  // QB age cliff 40+
  let qbAgeCliff40plus = 0;
  if (isQb && age >= 40) {
    const baseRisk = (age - 40) / 5;
    const injuryRisk = projectedGames < 14 ? ((14 - projectedGames) / 14 * 0.5) : 0;
    const declineRisk = rawFpChange < -0.1 ? Math.abs(rawFpChange) * 0.5 : 0;
    qbAgeCliff40plus = Math.min(baseRisk + injuryRisk + declineRisk, 1.0);
  }

  // Elite partial season resilience
  let elitePartialSeasonResilience = 0;
  if (startKtcNorm > 0.7 && projectedGames < 15) {
    const ultraEliteFactor = Math.min((startKtcNorm - 0.7) * 3.33, 1.0);
    const fpPerGameSignal = Math.min((projectedFP / Math.max(projectedGames, 1)) / 18, 1.0);
    elitePartialSeasonResilience = Math.min(ultraEliteFactor * fpPerGameSignal, 1.0);
  }

  // Career prime factor (from rookie year)
  const currentYear = 2025;
  const yearsSinceRookie = rookieYear && rookieYear > 0 ? Math.max(0, currentYear - rookieYear) : yearsExp;
  let careerPrimeFactor: number;
  if (yearsSinceRookie >= 2 && yearsSinceRookie <= 4) {
    careerPrimeFactor = 1.0;
  } else if (yearsSinceRookie < 2) {
    careerPrimeFactor = 0.8;
  } else {
    careerPrimeFactor = Math.max(0, 1 - (yearsSinceRookie - 4) / 8);
  }

  // Red zone features (estimate from FP and position)
  const redZoneTargetsNorm = position === 'WR' || position === 'TE'
    ? Math.min(stats.receivingTds * 3 / 30, 1.0)
    : 0;
  const redZoneTouchesNorm = position === 'RB'
    ? Math.min((stats.rushingTds * 4) / 50, 1.0)
    : redZoneTargetsNorm;
  const redZoneEfficiencyNorm = redZoneTouchesNorm > 0
    ? Math.min((stats.receivingTds + stats.rushingTds) / Math.max(redZoneTouchesNorm * 50, 1), 1.0)
    : 0;

  // Advanced receiving features (estimated from FP)
  const airYardsNorm = Math.min(stats.receivingYards * 0.7 / 1500, 1.0);
  const yacNorm = Math.min(stats.receivingYards * 0.3 / 800, 1.0);
  const yacPerRecNorm = stats.receptions > 0 ? Math.min((stats.receivingYards * 0.3 / stats.receptions) / 10, 1.0) : 0.5;
  const airYardsPerTgtNorm = stats.targets > 0 ? Math.min((stats.receivingYards * 0.7 / stats.targets) / 15, 1.0) : 0.5;
  const dropRateNorm = 0.1; // Neutral default
  const receivingFdNorm = Math.min(stats.receptions * 0.5 / 60, 1.0);

  // Advanced rushing features
  const rushingFdNorm = Math.min(stats.carries * 0.25 / 70, 1.0);
  const brokenTacklesNorm = 0.5; // Neutral default
  const rushShareNorm = isRb ? Math.min(stats.carries / 300, 1.0) : 0;

  // Advanced passing features
  const completionRateNorm = isQb ? 0.65 : 0; // Neutral ~65%
  const sackRateNorm = isQb ? 0.3 : 0; // Neutral
  const passingFdNorm = isQb ? Math.min(stats.passingTds * 5 / 200, 1.0) : 0;

  // Weekly-derived features (neutral defaults for projections)
  const weeklyFpCv = 0.5;
  const momentumRatio = 0.5;
  const boomRate = 0.2;
  const bustRate = 0.2;
  const last4VsSeason = 0.5;
  const maxGamesMissedStreak = 0;
  const ktcWeeklyVolatility = 0;

  // Team volume features (neutral defaults)
  const teamPassFactor = 1.0;
  const teamRushFactor = 1.0;
  const opportunityCeiling = targetShare * teamPassFactor;
  const rushOpportunity = carriesNorm * teamRushFactor;
  const teamVolumeCombined = 1.0;

  // Snap trend features (neutral defaults)
  const snapTrend = 0;
  const snapCollapse = 0;
  const snapConsistency = 1.0;

  // Weekly KTC market features (neutral defaults)
  const ktcTrendAcceleration = 0;
  const midSeasonCorrection = 0;
  const ktcMomentum = (ktc90d + 1) / 2;

  // PFF features (neutral defaults - no PFF data for projections)
  const pffGradeNorm = 0.5;
  const pffHasData = 0;
  const pffGradeConfidence = 0;
  const pffPositionGrade = 0.5;
  const pffGradeDivergence = 0.5;
  const pffGradeTrajectory = 0.5;
  const pffWrSeparation = 0.5;
  const pffWrContestedCatch = 0.5;
  const pffRbElusiveRating = 0.5;
  const pffRbReceivingGrade = 0.5;
  const pffQbAccuracy = 0.5;
  const pffQbPressureGrade = 0.5;
  const pffGradeVolatility = 0.5;
  const pffYouthPremium = ageYouthFactor * pffGradeNorm;
  const pffDeclineAlert = 0;
  const pffGradeSnapDivergence = 0.5;
  const pffEliteIndicator = 0;
  const pffBustRisk = 0;
  const pffBreakoutProbability = 0;
  const pffDynastyScore = 0.5;

  // =====================================================
  // BIAS CORRECTION FEATURES (11 features)
  // =====================================================

  // 1. Veteran decline risk
  let veteranDeclineRisk = 0;
  if (age >= 28) {
    const ageRisk = Math.min((age - 28) / 8, 1.0);
    let declineAmplifier = 1.0;
    if (rawFpChange < 0) {
      declineAmplifier = 1.0 + Math.abs(rawFpChange);
    }
    const productionDamper = Math.max(0.3, 1 - fpNorm);
    veteranDeclineRisk = Math.min(ageRisk * declineAmplifier * productionDamper, 1.0);
  }

  // 2. RB age penalty
  let rbAgePenalty = 0;
  if (isRb && age >= 27) {
    const basePenalty = (age - 27) / 3;
    const workloadAmplifier = 1.0 + (carriesNorm * 0.5);
    rbAgePenalty = Math.min(basePenalty * workloadAmplifier, 1.0);
  }

  // 3. WR/TE age penalty
  let wrTeAgePenalty = 0;
  if ((isWr || isTe) && age >= 30) {
    wrTeAgePenalty = Math.min((age - 30) / 4, 1.0);
  }

  // 4. Binary age flag
  const age31PlusFlag = age >= 31 ? 1 : 0;

  // 5. Age decline signal
  const ageComponent = Math.max(0, (age - 28) / 10);
  let fpDeclineComponent = 0;
  if (rawFpChange < 0) {
    fpDeclineComponent = Math.min(Math.abs(rawFpChange), 0.5);
  }
  const ageDeclineSignal = Math.min(ageComponent + fpDeclineComponent, 1.0);

  // 6. Value depreciation risk
  const cliffRisk = cliffYearsPenalty * 0.3;
  const valueRisk = Math.max(0, startKtcNorm - 0.3) * 0.2;
  const declineRisk = yoyDeclineSeverity * 0.3;
  const trajectoryRisk = Math.max(0, 0.5 - fpTrajectory) * 0.2;
  const valueDepreciationRisk = Math.min(cliffRisk + valueRisk + declineRisk + trajectoryRisk, 1.0);

  // 7. Veteran with declining FP (binary)
  const veteranWithDecliningFp = (age >= 31 && rawFpChange < 0) ? 1 : 0;

  // 8. Mid-tier depreciation signal
  let midTierDepreciationSignal = 0;
  if (startKtcNorm >= 0.2 && startKtcNorm <= 0.6) {
    const baseSignal = 0.3;
    const ageAmplifier = 1.0 + Math.max(0, (age - 26) / 10);
    const rangeCenter = 0.4;
    const distanceFromCenter = Math.abs(startKtcNorm - rangeCenter) / 0.2;
    const rangeFactor = Math.max(0.5, 1 - distanceFromCenter);
    midTierDepreciationSignal = Math.min(baseSignal * ageAmplifier * rangeFactor, 1.0);
  }

  // 9. Snap percentage decline (no prior data for projections)
  const snapPctDecline = 0;

  // 10. Starter to backup risk
  let starterToBackupRisk = 0;
  if (snapPctNorm < 0.5 && startKtcNorm > 0.3) {
    const ageRiskComponent = Math.max(0, (age - 26) / 10);
    const marginalStarterComponent = (snapPctNorm >= 0.4 && snapPctNorm < 0.6) ? 0.3 : 0;
    starterToBackupRisk = Math.min(ageRiskComponent + marginalStarterComponent, 1.0);
  }

  // 11. Mid-tier regression factor
  let midTierRegressionFactor = 0;
  if (startKtcNorm >= 0.2 && startKtcNorm <= 0.6) {
    const eliteFpThreshold = 0.6;
    const productionGap = Math.max(0, eliteFpThreshold - fpNorm);
    const rangeCenter = 0.4;
    const distanceFromCenter = Math.abs(startKtcNorm - rangeCenter) / 0.2;
    midTierRegressionFactor = productionGap * Math.max(0.3, 1 - distanceFromCenter);
  }

  // =====================================================
  // PHASE 2 CALIBRATION FEATURES (12 features)
  // =====================================================

  // 1. QB stability premium: Reduce age penalty by 50% for QBs
  const qbStabilityPremium = isQb ? 0.5 * (1 - ageFactor) : 0;

  // 2. QB scarcity factor: Top-12 QB value floor protection
  const qbScarcityFactor = (isQb && startKtcNorm > 0.7) ? 0.15 : 0;

  // 3. RB accelerated decline: 1.5x age penalty for RBs 28+
  const rbAcceleratedDecline = (isRb && age >= 28) ? Math.min(1.5 * rbAgePenalty, 1.0) : 0;

  // 4. Position cliff multiplier: Position-specific exponential cliff
  const positionCliffMultipliers: Record<string, number> = { QB: 0.8, RB: 1.5, WR: 1.2, TE: 1.1 };
  const positionCliffMultiplier = (positionCliffMultipliers[position] || 1.0) * cliffYearsPenalty;

  // 5. Elite young upside: Bonus for elite players under 27
  const eliteYoungUpside = (startKtcNorm > 0.8 && age < 27) ? 0.15 : 0;

  // 6. Elite momentum amplifier: 1.5x weight on KTC trend for elite players
  const eliteMomentumAmplifier = (startKtcNorm > 0.8) ? ktcMomentum * 1.5 : 0;

  // 7. Breakout trajectory: Identifies rapid value ascent (young player KTC jumped significantly)
  const breakoutTrajectory = (age <= 25 && ktcMomentum > 0.1) ? 1.0 : 0;

  // 8. Tier-2 hope discount: Base 15% regression risk for 4000-6000 KTC
  const tier2HopeDiscount = (startKtcNorm >= 0.4 && startKtcNorm < 0.6) ? 0.15 : 0;

  // 9. Non-starter depreciation: Penalty for <70% snap share at mid value
  const nonStarterDepreciation = (snapPct < 0.7 && startKtcNorm > 0.4) ? 0.1 : 0;

  // 10. One-hit wonder risk: First big season + age 26+ = regression signal
  const oneHitWonderRisk = (age >= 26 && yearsExp <= 3 && fpNorm > 0.4 && priorFpNorm < 0.3) ? 0.2 : 0;

  // 11. Peak season risk: High GP + high FP = potential ceiling/regression
  const peakSeasonRisk = (projectedGames >= 16 && fpPerGame > 0.6) ? 0.1 : 0;

  // 12. Buy low recovery: Injured young players have upside
  const buyLowRecovery = (projectedGames < 10 && age < 28 && startKtcNorm > 0.3) ? 0.1 : 0;

  // =====================================================
  // PHASE 3 CALIBRATION FEATURES (12 features for TE, breakout, young/veteran)
  // =====================================================

  // --- TE Position Boost (TEs under-predicted by -98 pts avg) ---

  // 1. TE upside amplifier: TEs have unique value in dynasty due to scarcity
  let teUpsideAmplifier = 0;
  if (isTe) {
    const basePremium = 0.15;
    const youthBoost = Math.max(0, (27 - age) / 10) * 0.15;
    const productionBoost = fpNorm * 0.2;
    teUpsideAmplifier = Math.min(basePremium + youthBoost + productionBoost, 0.5);
  }

  // 2. TE elite ceiling: Elite TEs have higher ceiling
  let teEliteCeiling = 0;
  if (isTe && startKtcNorm > 0.6) {
    const eliteBase = 0.2;
    const youthAmplifier = Math.max(0, (28 - age) / 5);
    teEliteCeiling = Math.min(eliteBase * (1 + youthAmplifier), 0.5);
  }

  // 3. TE breakout indicator: Young TEs showing production breakout
  let teBreakoutIndicator = 0;
  if (isTe && age <= 26) {
    if (rawFpChange && rawFpChange > 0.2) {
      teBreakoutIndicator = 0.3;
    } else if (fpNorm > 0.3 && priorFpNorm < 0.2) {
      teBreakoutIndicator = 0.25;
    }
  }

  // --- Breakout Detection (70.9% of breakouts under-predicted) ---

  // 4. Breakout potential ceiling: Combines multiple breakout signals
  let breakoutPotentialCeiling = 0;
  if (age <= 25) {
    const ktcMomentumSignal = Math.max(0, ktcMomentum) * 0.3;
    const fpTrajectorySignal = Math.max(0, fpTrajectory - 0.5) * 0.4;
    const productionJump = rawFpChange ? Math.max(0, rawFpChange) * 0.3 : 0;
    breakoutPotentialCeiling = Math.min(ktcMomentumSignal + fpTrajectorySignal + productionJump, 0.5);
  }

  // 5. Rookie draft capital ceiling: High draft capital rookies have upside
  let rookieDraftCapitalCeiling = 0;
  if (yearsExp <= 2) {
    if (draftRoundValue > 0.85) {
      rookieDraftCapitalCeiling = 0.3;
    } else if (draftRoundValue > 0.7) {
      rookieDraftCapitalCeiling = 0.2;
    } else if (draftRoundValue > 0.55) {
      rookieDraftCapitalCeiling = 0.1;
    }
  }

  // 6. Momentum ceiling amplifier: Strong positive momentum deserves higher ceiling
  const momentumCeilingAmplifier = (ktcMomentum > 0.1 && age <= 27)
    ? Math.min(ktcMomentum * 1.5, 0.4)
    : 0;

  // --- Young Player Calibration (Young <=24 under-predicted by -84 pts) ---

  // 7. Young elite ceiling boost: Young elite players have highest ceiling
  let youngEliteCeilingBoost = 0;
  if (age <= 24 && startKtcNorm > 0.7) {
    const youthPremium = (25 - age) / 5;
    const elitePremium = (startKtcNorm - 0.7) * 3.33;
    youngEliteCeilingBoost = Math.min(youthPremium * elitePremium * 0.4, 0.4);
  }

  // 8. Career trajectory boost: Young players on upward trajectory
  const careerTrajectoryBoost = (age <= 26 && fpTrajectory > 0.6)
    ? (fpTrajectory - 0.5) * 0.5
    : 0;

  // --- Veteran Decline Enhancement (Veterans 31+ over-predicted by +174 pts) ---

  // 9. Veteran steep decline: Much stronger penalty for 35+ players
  let veteranSteepDecline = 0;
  if (age >= 35) {
    const basePenalty = (age - 35) / 5;
    let declineAmplifier = 1.0;
    if (rawFpChange && rawFpChange < 0) {
      declineAmplifier = 1.5;
    }
    if (isRb) {
      declineAmplifier *= 2.0;
    } else if (isQb) {
      declineAmplifier *= 0.7;
    }
    veteranSteepDecline = Math.min(basePenalty * declineAmplifier, 1.0);
  }

  // 10. Veteran QB over-prediction fix: QBs 38+ severely over-predicted
  const veteranQbCliff = (isQb && age >= 38)
    ? Math.min((age - 38) / 3, 1.0)
    : 0;

  // 11. Aging value compression: Older players lose value faster
  let agingValueCompression = 0;
  if (age >= 30) {
    const agePenaltyForCompression = (age - 30) / 8;
    const valueFactor = startKtcNorm > 0.3 ? startKtcNorm * 2 : 0.5;
    agingValueCompression = Math.min(agePenaltyForCompression * valueFactor, 0.8);
  }

  // 12. Position-age interaction: Combines position-specific aging with production
  let positionAgeInteraction = 0;
  const positionCliffAge = AGE_CLIFFS[position] || 30;
  if (age >= positionCliffAge) {
    const yearsOver = age - positionCliffAge;
    if (yearsOver <= 2) {
      positionAgeInteraction = yearsOver * 0.2;
    } else {
      positionAgeInteraction = 0.4 + (yearsOver - 2) * 0.15;
    }
    positionAgeInteraction = Math.min(positionAgeInteraction, 0.8);
  }

  // Return all 148 features in exact order matching Python model
  return [
    startKtcNorm,           // 0: start_ktc
    ktc30d,                 // 1: ktc_30d_trend
    ktc90d,                 // 2: ktc_90d_trend
    ageFactor,              // 3: age_factor
    yearsExpNorm,           // 4: years_exp_normalized
    fpNorm,                 // 5: fp_normalized
    gamesFactor,            // 6: games_played_factor
    fpPerGame,              // 7: fp_per_game
    priorFpNorm,            // 8: prior_fp_normalized
    priorFpPerGame,         // 9: prior_fp_per_game (NEW)
    fpPerGameChange,        // 10: fp_per_game_change (NEW)
    fpChangeYoy,            // 11: fp_change_yoy
    positionRankNorm,       // 12: position_rank_normalized
    ktcVolatility,          // 13: ktc_volatility
    isBreakoutCandidate,    // 14: is_breakout_candidate
    isQb,                   // 15: is_qb
    isRb,                   // 16: is_rb
    isWr,                   // 17: is_wr
    isTe,                   // 18: is_te
    receptionsNorm,         // 19: receptions_normalized
    targetsNorm,            // 20: targets_normalized
    receivingYardsNorm,     // 21: receiving_yards_normalized
    receivingTdsNorm,       // 22: receiving_tds_normalized
    yardsPerTarget,         // 23: yards_per_target
    targetShare,            // 24: target_share
    carriesNorm,            // 25: carries_normalized
    rushingYardsNorm,       // 26: rushing_yards_normalized
    rushingTdsNorm,         // 27: rushing_tds_normalized
    yardsPerCarry,          // 28: yards_per_carry
    passingYardsNorm,       // 29: passing_yards_normalized
    passingTdsNorm,         // 30: passing_tds_normalized
    interceptionsNorm,      // 31: interceptions_normalized
    draftRoundValue,        // 32: draft_round_value
    draftPickValue,         // 33: draft_pick_value
    ageFpInteraction,       // 34: age_fp_interaction
    cliffYearsPenalty,      // 35: cliff_years_penalty
    ageExpGap,              // 36: age_exp_gap
    snapPctNorm,            // 37: snap_pct_normalized
    fpPerSnap,              // 38: fp_per_snap
    eliteYouthPremium,      // 39: elite_youth_premium
    fpTrajectory,           // 40: fp_trajectory
    qbTdIntRatio,           // 41: qb_td_int_ratio
    qbRushingBonus,         // 42: qb_rushing_bonus
    qbAgePremium,           // 43: qb_age_premium
    qbEfficiency,           // 44: qb_efficiency
    isEliteTier,            // 45: is_elite_tier
    eliteAgeInteraction,    // 46: elite_age_interaction
    eliteTrajectoryInteraction, // 47: elite_trajectory_interaction
    eliteVolatilityDampener,// 48: elite_volatility_dampener
    efficiencyVolume,       // 49: efficiency_volume
    workloadIntensity,      // 50: workload_intensity
    tdConversionRate,       // 51: td_conversion_rate
    trajectoryCliffInteraction, // 52: trajectory_cliff_interaction
    draftPerformanceRatio,  // 53: draft_performance_ratio
    yoyDeclineSeverity,     // 54: yoy_decline_severity
    gamesPlayedCollapse,    // 55: games_played_collapse
    gapYearPenalty,         // 56: gap_year_penalty
    qbAgeCliff40plus,       // 57: qb_age_cliff_40plus
    elitePartialSeasonResilience, // 58: elite_partial_season_resilience
    // Rookie year and red zone features (4)
    careerPrimeFactor,      // 59: career_prime_factor
    redZoneTargetsNorm,     // 60: red_zone_targets_norm
    redZoneTouchesNorm,     // 61: red_zone_touches_norm
    redZoneEfficiencyNorm,  // 62: red_zone_efficiency_norm
    // Advanced receiving features (6)
    airYardsNorm,           // 63: air_yards_normalized
    yacNorm,                // 64: yac_normalized
    yacPerRecNorm,          // 65: yac_per_rec_norm
    airYardsPerTgtNorm,     // 66: air_yards_per_tgt_norm
    dropRateNorm,           // 67: drop_rate_normalized
    receivingFdNorm,        // 68: receiving_fd_norm
    // Advanced rushing features (3)
    rushingFdNorm,          // 69: rushing_fd_norm
    brokenTacklesNorm,      // 70: broken_tackles_norm
    rushShareNorm,          // 71: rush_share_norm
    // Advanced passing features (3)
    completionRateNorm,     // 72: completion_rate_norm
    sackRateNorm,           // 73: sack_rate_norm
    passingFdNorm,          // 74: passing_fd_norm
    // Weekly-derived features (7)
    weeklyFpCv,             // 75: weekly_fp_cv
    momentumRatio,          // 76: momentum_ratio
    boomRate,               // 77: boom_rate
    bustRate,               // 78: bust_rate
    last4VsSeason,          // 79: last_4_vs_season
    maxGamesMissedStreak,   // 80: max_games_missed_streak
    ktcWeeklyVolatility,    // 81: ktc_weekly_volatility
    // Team volume features (5)
    teamPassFactor,         // 82: team_pass_factor
    teamRushFactor,         // 83: team_rush_factor
    opportunityCeiling,     // 84: opportunity_ceiling
    rushOpportunity,        // 85: rush_opportunity
    teamVolumeCombined,     // 86: team_volume_combined
    // Snap trend features (3)
    snapTrend,              // 87: snap_trend
    snapCollapse,           // 88: snap_collapse
    snapConsistency,        // 89: snap_consistency
    // Weekly KTC market features (3)
    ktcTrendAcceleration,   // 90: ktc_trend_acceleration
    midSeasonCorrection,    // 91: mid_season_correction
    ktcMomentum,            // 92: ktc_momentum
    // PFF features (20)
    pffGradeNorm,           // 93: pff_grade_normalized
    pffHasData,             // 94: pff_has_data
    pffGradeConfidence,     // 95: pff_grade_confidence
    pffPositionGrade,       // 96: pff_position_grade
    pffGradeDivergence,     // 97: pff_grade_divergence
    pffGradeTrajectory,     // 98: pff_grade_trajectory
    pffWrSeparation,        // 99: pff_wr_separation
    pffWrContestedCatch,    // 100: pff_wr_contested_catch
    pffRbElusiveRating,     // 101: pff_rb_elusive_rating
    pffRbReceivingGrade,    // 102: pff_rb_receiving_grade
    pffQbAccuracy,          // 103: pff_qb_accuracy
    pffQbPressureGrade,     // 104: pff_qb_pressure_grade
    pffGradeVolatility,     // 105: pff_grade_volatility
    pffYouthPremium,        // 106: pff_youth_premium
    pffDeclineAlert,        // 107: pff_decline_alert
    pffGradeSnapDivergence, // 108: pff_grade_snap_divergence
    pffEliteIndicator,      // 109: pff_elite_indicator
    pffBustRisk,            // 110: pff_bust_risk
    pffBreakoutProbability, // 111: pff_breakout_probability
    pffDynastyScore,        // 112: pff_dynasty_score
    // Bias correction features (11)
    veteranDeclineRisk,     // 113: veteran_decline_risk
    rbAgePenalty,           // 114: rb_age_penalty
    wrTeAgePenalty,         // 115: wr_te_age_penalty
    age31PlusFlag,          // 116: age_31_plus_flag
    ageDeclineSignal,       // 117: age_decline_signal
    valueDepreciationRisk,  // 118: value_depreciation_risk
    veteranWithDecliningFp, // 119: veteran_with_declining_fp
    midTierDepreciationSignal, // 120: mid_tier_depreciation_signal
    snapPctDecline,         // 121: snap_pct_decline
    starterToBackupRisk,    // 122: starter_to_backup_risk
    midTierRegressionFactor, // 123: mid_tier_regression_factor
    // Phase 2 calibration features (12)
    qbStabilityPremium,     // 124: qb_stability_premium
    qbScarcityFactor,       // 125: qb_scarcity_factor
    rbAcceleratedDecline,   // 126: rb_accelerated_decline
    positionCliffMultiplier, // 127: position_cliff_multiplier
    eliteYoungUpside,       // 128: elite_young_upside
    eliteMomentumAmplifier, // 129: elite_momentum_amplifier
    breakoutTrajectory,     // 130: breakout_trajectory
    tier2HopeDiscount,      // 131: tier2_hope_discount
    nonStarterDepreciation, // 132: non_starter_depreciation
    oneHitWonderRisk,       // 133: one_hit_wonder_risk
    peakSeasonRisk,         // 134: peak_season_risk
    buyLowRecovery,         // 135: buy_low_recovery
    // Phase 3 calibration features (12)
    teUpsideAmplifier,      // 136: te_upside_amplifier
    teEliteCeiling,         // 137: te_elite_ceiling
    teBreakoutIndicator,    // 138: te_breakout_indicator
    breakoutPotentialCeiling, // 139: breakout_potential_ceiling
    rookieDraftCapitalCeiling, // 140: rookie_draft_capital_ceiling
    momentumCeilingAmplifier, // 141: momentum_ceiling_amplifier
    youngEliteCeilingBoost, // 142: young_elite_ceiling_boost
    careerTrajectoryBoost,  // 143: career_trajectory_boost
    veteranSteepDecline,    // 144: veteran_steep_decline
    veteranQbCliff,         // 145: veteran_qb_cliff
    agingValueCompression,  // 146: aging_value_compression
    positionAgeInteraction, // 147: position_age_interaction
  ];
}

// ============================================================================
// Model Inference
// ============================================================================

// XGBoost tree prediction
function predictXGBoostTree(tree: XGBoostTree, features: number[]): number {
  let nodeIdx = 0;

  while (tree.left_children[nodeIdx] !== -1) {
    const featureIdx = tree.split_indices[nodeIdx];
    const threshold = tree.split_conditions[nodeIdx];
    const featureValue = features[featureIdx];

    if (Number.isNaN(featureValue)) {
      nodeIdx = tree.default_left[nodeIdx] === 1
        ? tree.left_children[nodeIdx]
        : tree.right_children[nodeIdx];
    } else if (featureValue < threshold) {
      nodeIdx = tree.left_children[nodeIdx];
    } else {
      nodeIdx = tree.right_children[nodeIdx];
    }
  }

  return tree.base_weights[nodeIdx];
}

// XGBoost ensemble prediction
function predictXGBoost(model: XGBoostModel, features: number[]): number {
  const baseScoreStr = model.learner.learner_model_param.base_score;
  const cleanedStr = baseScoreStr.replace(/[\[\]]/g, '');
  const baseScore = parseFloat(cleanedStr);

  const trees = model.learner.gradient_booster.model.trees;

  let sum = baseScore;
  for (const tree of trees) {
    sum += predictXGBoostTree(tree, features);
  }

  return sum;
}

// LightGBM tree traversal
function predictLightGBMTree(node: LightGBMNode, features: number[]): number {
  // Leaf node
  if (node.leaf_value !== undefined) {
    return node.leaf_value;
  }

  // Internal node - split on feature
  const featureIdx = node.split_feature!;
  const threshold = node.threshold!;
  const featureValue = features[featureIdx];

  // LightGBM uses <= for left branch (decision_type is "<=")
  if (featureValue <= threshold) {
    return predictLightGBMTree(node.left_child!, features);
  } else {
    return predictLightGBMTree(node.right_child!, features);
  }
}

// LightGBM ensemble prediction
function predictLightGBM(model: LightGBMModel, features: number[]): number {
  let sum = 0;

  for (const treeInfo of model.lightgbm_model.tree_info) {
    sum += predictLightGBMTree(treeInfo.tree_structure, features);
  }

  return sum;
}

// Ensemble prediction (40% XGBoost + 60% LightGBM)
function predictEnsemble(
  xgbModel: XGBoostModel,
  lgbModel: LightGBMModel,
  features: number[]
): number {
  const xgbPred = predictXGBoost(xgbModel, features);
  const lgbPred = predictLightGBM(lgbModel, features);

  // Optimized weights from training
  return 0.4 * xgbPred + 0.6 * lgbPred;
}

// ============================================================================
// PFF Model Prediction (new JSON dump format from train_pff_rolling.py)
// ============================================================================

// XGBoost JSON dump tree node structure
interface XGBoostJsonNode {
  nodeid: number;
  depth?: number;
  split?: string;  // Feature name like "f0", "f1"
  split_condition?: number;
  yes?: number;
  no?: number;
  missing?: number;
  children?: XGBoostJsonNode[];
  leaf?: number;
}

// PFF XGBoost model structure
interface PffXgboostModel {
  metadata: {
    model_type: string;
    test_year: number;
    train_years: string;
    mae_ktc: number | null;
    r2_score: number | null;
    n_features: number;
    feature_names: string[];
  };
  xgboost_model: {
    n_estimators: number;
    base_score: number;
    trees: XGBoostJsonNode[];
  };
}

// Traverse XGBoost JSON dump tree
function predictXgboostJsonTree(node: XGBoostJsonNode, features: number[]): number {
  // Leaf node
  if (node.leaf !== undefined) {
    return node.leaf;
  }

  // Internal node - get feature index from "fN" format
  const featureIdx = parseInt(node.split!.replace('f', ''), 10);
  const threshold = node.split_condition!;
  const featureValue = features[featureIdx];

  // Find child nodes
  const children = node.children || [];
  const yesNode = children.find(c => c.nodeid === node.yes);
  const noNode = children.find(c => c.nodeid === node.no);

  // XGBoost uses < for yes branch
  if (featureValue < threshold) {
    return yesNode ? predictXgboostJsonTree(yesNode, features) : 0;
  } else {
    return noNode ? predictXgboostJsonTree(noNode, features) : 0;
  }
}

// PFF XGBoost ensemble prediction
function predictPffXgboost(model: PffXgboostModel, features: number[]): number {
  const baseScore = model.xgboost_model.base_score;
  let sum = baseScore;

  for (const tree of model.xgboost_model.trees) {
    sum += predictXgboostJsonTree(tree, features);
  }

  return sum;
}

// PFF Ensemble prediction (40% XGBoost + 60% LightGBM)
function predictPffEnsemble(
  xgbModel: PffXgboostModel,
  lgbModel: LightGBMModel,
  features: number[]
): number {
  const xgbPred = predictPffXgboost(xgbModel, features);
  const lgbPred = predictLightGBM(lgbModel, features);

  // Same weights as Python training
  return 0.4 * xgbPred + 0.6 * lgbPred;
}


// ============================================================================
// Model Loading (cached)
// ============================================================================

// Cache for year-specific PFF models
const pffModelCache: Record<number, { xgb: any; lgb: LightGBMModel }> = {};
let cachedLgbQ10Model: LightGBMModel | null = null;
let cachedLgbQ90Model: LightGBMModel | null = null;

// Cache for tier-specific models (key: "year-tier")
const tierModelCache: Record<string, { xgb: any; lgb: LightGBMModel }> = {};

// Legacy model cache (fallback)
let cachedXgbModel: XGBoostModel | null = null;
let cachedLgbModel: LightGBMModel | null = null;

/**
 * Load tier-specific models for improved accuracy.
 * Uses hybrid approach: only loads tier models for tiers where they outperform unified.
 * Falls back to year-level models for mid/tier2 (where unified has better MAE).
 */
function loadTierModels(year: number, tier: Tier): { xgb: any; lgb: LightGBMModel } | null {
  // Hybrid approach: only use tier-specific models where they improve accuracy
  if (!HYBRID_TIERS.includes(tier)) {
    return null;  // Fall back to unified model for mid/tier2
  }

  const modelYear = PFF_MODEL_PATHS[year] ? year : 2026;
  const cacheKey = `${modelYear}-${tier}`;

  if (tierModelCache[cacheKey]) {
    return tierModelCache[cacheKey];
  }

  const paths = getTierModelPaths(modelYear, tier);
  try {
    if (fs.existsSync(paths.xgb) && fs.existsSync(paths.lgb)) {
      const xgb = JSON.parse(fs.readFileSync(paths.xgb, 'utf-8'));
      const lgb = JSON.parse(fs.readFileSync(paths.lgb, 'utf-8'));
      tierModelCache[cacheKey] = { xgb, lgb };
      return tierModelCache[cacheKey];
    }
  } catch (e) {
    console.error(`Failed to load tier-specific models for ${cacheKey}:`, e);
  }

  // Tier-specific model not available
  return null;
}

function loadPffModels(year: number): { xgb: any; lgb: LightGBMModel } {
  // Default to 2026 (production model) if year not found
  const modelYear = PFF_MODEL_PATHS[year] ? year : 2026;

  if (pffModelCache[modelYear]) {
    return pffModelCache[modelYear];
  }

  const paths = PFF_MODEL_PATHS[modelYear];
  try {
    const xgb = JSON.parse(fs.readFileSync(paths.xgb, 'utf-8'));
    const lgb = JSON.parse(fs.readFileSync(paths.lgb, 'utf-8'));
    pffModelCache[modelYear] = { xgb, lgb };
    return pffModelCache[modelYear];
  } catch (e) {
    console.error(`Failed to load PFF models for year ${modelYear}:`, e);
    // Fall back to legacy models
    return loadModels() as { xgb: any; lgb: LightGBMModel };
  }
}

function loadModels(): { xgb: XGBoostModel; lgb: LightGBMModel } {
  if (!cachedXgbModel) {
    cachedXgbModel = JSON.parse(fs.readFileSync(xgbModelPath, 'utf-8'));
  }
  if (!cachedLgbModel) {
    cachedLgbModel = JSON.parse(fs.readFileSync(lgbModelPath, 'utf-8'));
  }
  return { xgb: cachedXgbModel!, lgb: cachedLgbModel! };
}

function loadQuantileModels(): { q10: LightGBMModel; q90: LightGBMModel } | null {
  try {
    if (!cachedLgbQ10Model) {
      cachedLgbQ10Model = JSON.parse(fs.readFileSync(lgbQ10ModelPath, 'utf-8'));
    }
    if (!cachedLgbQ90Model) {
      cachedLgbQ90Model = JSON.parse(fs.readFileSync(lgbQ90ModelPath, 'utf-8'));
    }
    return { q10: cachedLgbQ10Model!, q90: cachedLgbQ90Model! };
  } catch {
    // Quantile models are optional
    return null;
  }
}

// Get confidence level based on prediction interval width
function getConfidence(intervalWidth: number): 'high' | 'medium' | 'low' {
  if (intervalWidth < 500) return 'high';
  if (intervalWidth < 1000) return 'medium';
  return 'low';
}

// Calculate baseline FP from player's historical seasons
function calculateBaselineFP(player: PlayerChartData): number {
  if (player.seasons.length === 0) return 0;

  const totalFP = player.seasons.reduce((sum, s) => sum + s.fantasyPoints, 0);
  const totalGames = player.seasons.reduce((sum, s) => sum + s.gamesPlayed, 0);
  const avgFpPerGame = totalGames > 0 ? totalFP / totalGames : 0;

  return avgFpPerGame * GAMES_PER_SEASON;
}

interface PredictionWithUncertainty {
  predictedKtc: number;
  predictedKtcLow: number | null;
  predictedKtcHigh: number | null;
  intervalWidth: number | null;
  confidence: 'high' | 'medium' | 'low' | null;
}

// Prediction function using the ensemble model with uncertainty
function predictKtcForFPAndGamesWithUncertainty(
  player: PlayerChartData,
  baselineFP: number,
  projectedFP: number,
  projectedGames: number,
  modelYear: number = 2026  // Default to production model
): PredictionWithUncertainty {
  // Detect tier based on player's current KTC
  const tier = detectTier(player.latestKtc);

  // Try tier-specific models first, fall back to year-level models
  const tierModels = loadTierModels(modelYear, tier);
  const { xgb, lgb } = tierModels || loadPffModels(modelYear);
  const quantileModels = loadQuantileModels();

  const features = extractEnhancedFeatures(
    player.latestKtc,
    player.ktc30dTrend || 0,
    player.ktc90dTrend || 0,
    player.currentAge,
    player.yearsExp,
    projectedFP,
    projectedGames,
    player.position,
    baselineFP,
    player.historicalSnapPct || 0.8
  );

  // Use PFF ensemble prediction - CHANGE PREDICTION
  // Model predicts (end_ktc - start_ktc) / KTC_MAX, then we add start_ktc to get end value
  const startKtcForPrediction = features[0] * KTC_MAX_VALUE;  // Denormalize start_ktc (feature 0)
  const predictedChange = predictPffEnsemble(xgb as PffXgboostModel, lgb, features);
  const predictedKtc = Math.min(Math.max(Math.round(startKtcForPrediction + predictedChange * KTC_MAX_VALUE), 0), KTC_MAX_VALUE);

  // Get quantile predictions for uncertainty
  let predictedKtcLow: number | null = null;
  let predictedKtcHigh: number | null = null;
  let intervalWidth: number | null = null;
  let confidence: 'high' | 'medium' | 'low' | null = null;

  if (quantileModels) {
    const q10Pred = predictLightGBM(quantileModels.q10, features);
    const q90Pred = predictLightGBM(quantileModels.q90, features);

    predictedKtcLow = Math.min(Math.max(Math.round(q10Pred * KTC_MAX_VALUE), 0), KTC_MAX_VALUE);
    predictedKtcHigh = Math.min(Math.max(Math.round(q90Pred * KTC_MAX_VALUE), 0), KTC_MAX_VALUE);
    intervalWidth = predictedKtcHigh - predictedKtcLow;
    confidence = getConfidence(intervalWidth);
  }

  return {
    predictedKtc,
    predictedKtcLow,
    predictedKtcHigh,
    intervalWidth,
    confidence,
  };
}

// Prediction function using the ensemble model (backward compatible)
function predictKtcForFPAndGames(
  player: PlayerChartData,
  baselineFP: number,
  projectedFP: number,
  projectedGames: number
): number {
  return predictKtcForFPAndGamesWithUncertainty(player, baselineFP, projectedFP, projectedGames).predictedKtc;
}

// Historical prediction function with uncertainty
function predictKtcForFPAndGamesHistoricalWithUncertainty(
  player: PlayerChartData,
  season: SeasonData,
  baselineFP: number,
  projectedFP: number,
  projectedGames: number,
  ageAtSeason: number,
  yearsExpAtSeason: number,
  modelYear: number = 2026  // Use year-specific model
): PredictionWithUncertainty {
  // Detect tier based on season's start KTC
  const tier = detectTier(season.startKtc);

  // Try tier-specific models first, fall back to year-level models
  const tierModels = loadTierModels(modelYear, tier);
  const { xgb, lgb } = tierModels || loadPffModels(modelYear);
  const quantileModels = loadQuantileModels();

  const features = extractEnhancedFeatures(
    season.startKtc,
    player.ktc30dTrend || 0,
    player.ktc90dTrend || 0,
    ageAtSeason,
    yearsExpAtSeason,
    projectedFP,
    projectedGames,
    player.position,
    baselineFP,
    player.historicalSnapPct || 0.8
  );

  // Use PFF ensemble prediction - CHANGE PREDICTION
  // Model predicts (end_ktc - start_ktc) / KTC_MAX, then we add start_ktc to get end value
  const startKtcForPrediction = features[0] * KTC_MAX_VALUE;  // Denormalize start_ktc (feature 0)
  const predictedChange = predictPffEnsemble(xgb as PffXgboostModel, lgb, features);
  const predictedKtc = Math.min(Math.max(Math.round(startKtcForPrediction + predictedChange * KTC_MAX_VALUE), 0), KTC_MAX_VALUE);

  // Get quantile predictions for uncertainty
  let predictedKtcLow: number | null = null;
  let predictedKtcHigh: number | null = null;
  let intervalWidth: number | null = null;
  let confidence: 'high' | 'medium' | 'low' | null = null;

  if (quantileModels) {
    const q10Pred = predictLightGBM(quantileModels.q10, features);
    const q90Pred = predictLightGBM(quantileModels.q90, features);

    predictedKtcLow = Math.min(Math.max(Math.round(q10Pred * KTC_MAX_VALUE), 0), KTC_MAX_VALUE);
    predictedKtcHigh = Math.min(Math.max(Math.round(q90Pred * KTC_MAX_VALUE), 0), KTC_MAX_VALUE);
    intervalWidth = predictedKtcHigh - predictedKtcLow;
    confidence = getConfidence(intervalWidth);
  }

  return {
    predictedKtc,
    predictedKtcLow,
    predictedKtcHigh,
    intervalWidth,
    confidence,
  };
}

// Historical prediction function (backward compatible)
function predictKtcForFPAndGamesHistorical(
  player: PlayerChartData,
  season: SeasonData,
  baselineFP: number,
  projectedFP: number,
  projectedGames: number,
  ageAtSeason: number,
  yearsExpAtSeason: number,
  modelYear: number = 2026
): number {
  return predictKtcForFPAndGamesHistoricalWithUncertainty(
    player, season, baselineFP, projectedFP, projectedGames, ageAtSeason, yearsExpAtSeason, modelYear
  ).predictedKtc;
}

// ============================================================================
// API Handler
// ============================================================================

export async function GET(req: NextRequest) {
  const { searchParams } = new URL(req.url);
  const playerId = searchParams.get('playerId');
  const gamesParam = searchParams.get('games');
  const yearParam = searchParams.get('year');

  if (!playerId) {
    return NextResponse.json({ error: 'playerId is required' }, { status: 400 });
  }

  const projectedGames = gamesParam ? parseInt(gamesParam, 10) : 17;
  const historicalYear = yearParam ? parseInt(yearParam, 10) : null;

  if (isNaN(projectedGames) || projectedGames < 0 || projectedGames > 17) {
    return NextResponse.json({ error: 'games must be between 0 and 17' }, { status: 400 });
  }

  try {
    const chartData: ChartDataOutput = JSON.parse(fs.readFileSync(chartDataPath, 'utf-8'));
    const player = chartData.players.find(p => p.playerId === playerId);

    if (!player) {
      return NextResponse.json({ error: 'Player not found' }, { status: 404 });
    }

    const baselineFP = calculateBaselineFP(player);

    // Generate predictions for FP/game range
    const rangeMax = 25;
    const fpPerGameRange: number[] = [];
    for (let fp = 0; fp <= rangeMax; fp += 0.5) {
      fpPerGameRange.push(fp);
    }

    const historicalSeason = historicalYear
      ? player.seasons.find(s => s.year === historicalYear)
      : null;

    const latestSeasonYear = player.seasons.length > 0
      ? Math.max(...player.seasons.map(s => s.year))
      : 2025;
    const yearsDiff = historicalYear ? latestSeasonYear - historicalYear + 1 : 0;
    const ageAtSeason = historicalSeason ? player.currentAge - yearsDiff : player.currentAge;
    const yearsExpAtSeason = historicalSeason ? Math.max(0, player.yearsExp - yearsDiff) : player.yearsExp;

    const baseKtc = historicalSeason ? historicalSeason.startKtc : player.latestKtc;

    const historicalAvgGames = player.seasons.length > 0
      ? Math.round(player.seasons.reduce((sum, s) => sum + s.gamesPlayed, 0) / player.seasons.length)
      : 17;

    // Determine which model year to use
    const modelYear = historicalYear || 2026;

    const predictions = fpPerGameRange.map(fpPerGame => {
      const totalFP = fpPerGame * projectedGames;

      let predResult: PredictionWithUncertainty;
      if (historicalSeason && historicalYear) {
        predResult = predictKtcForFPAndGamesHistoricalWithUncertainty(
          player, historicalSeason, baselineFP, totalFP, projectedGames,
          ageAtSeason, yearsExpAtSeason, historicalYear
        );
      } else {
        predResult = predictKtcForFPAndGamesWithUncertainty(player, baselineFP, totalFP, projectedGames, modelYear);
      }

      return {
        projectedFPPerGame: fpPerGame,
        predictedKtc: predResult.predictedKtc,
        predictedKtcLow: predResult.predictedKtcLow,
        predictedKtcHigh: predResult.predictedKtcHigh,
      };
    });

    // Get uncertainty info for the baseline prediction (at average FP/game)
    const baselineUncertainty = historicalSeason && historicalYear
      ? predictKtcForFPAndGamesHistoricalWithUncertainty(
          player, historicalSeason, baselineFP, baselineFP, projectedGames,
          ageAtSeason, yearsExpAtSeason, historicalYear
        )
      : predictKtcForFPAndGamesWithUncertainty(player, baselineFP, baselineFP, projectedGames, modelYear);

    // Binary search for breakeven
    let breakevenFPPerGame: number | null = null;
    const targetKtc = baseKtc;
    const maxFpPerGame = fpPerGameRange[fpPerGameRange.length - 1];
    let low = 0;
    let high = maxFpPerGame * 1.5;

    for (let i = 0; i < 20; i++) {
      const mid = (low + high) / 2;
      const totalFP = mid * projectedGames;

      const predictedKtc = historicalSeason && historicalYear
        ? predictKtcForFPAndGamesHistorical(
            player, historicalSeason, baselineFP, totalFP, projectedGames,
            ageAtSeason, yearsExpAtSeason, historicalYear
          )
        : predictKtcForFPAndGames(player, baselineFP, totalFP, projectedGames);

      if (Math.abs(predictedKtc - targetKtc) < 10) {
        breakevenFPPerGame = Math.round(mid * 10) / 10;
        break;
      }

      if (predictedKtc < targetKtc) {
        low = mid;
      } else {
        high = mid;
      }
    }

    if (breakevenFPPerGame !== null && !predictions.some(p => Math.abs(p.projectedFPPerGame - breakevenFPPerGame!) < 0.5)) {
      // Get uncertainty for breakeven point
      const totalFP = breakevenFPPerGame * projectedGames;
      const breakevenUncertainty = historicalSeason && historicalYear
        ? predictKtcForFPAndGamesHistoricalWithUncertainty(
            player, historicalSeason, baselineFP, totalFP, projectedGames,
            ageAtSeason, yearsExpAtSeason, historicalYear
          )
        : predictKtcForFPAndGamesWithUncertainty(player, baselineFP, totalFP, projectedGames, modelYear);

      predictions.push({
        projectedFPPerGame: breakevenFPPerGame,
        predictedKtc: targetKtc,
        predictedKtcLow: breakevenUncertainty.predictedKtcLow,
        predictedKtcHigh: breakevenUncertainty.predictedKtcHigh,
      });
      predictions.sort((a, b) => a.projectedFPPerGame - b.projectedFPPerGame);
    }

    const response: Record<string, unknown> = {
      playerId: player.playerId,
      name: player.name,
      position: player.position,
      currentAge: historicalSeason ? ageAtSeason : player.currentAge,
      yearsExp: historicalSeason ? yearsExpAtSeason : player.yearsExp,
      latestKtc: baseKtc,
      projectedGames,
      historicalAvgGames,
      confidenceScore: player.confidenceScore,
      confidenceFactors: player.confidenceFactors,
      breakevenFPPerGame,
      predictions,
      // Uncertainty estimation from quantile models
      uncertainty: baselineUncertainty.intervalWidth !== null ? {
        predictionIntervalWidth: baselineUncertainty.intervalWidth,
        confidence: baselineUncertainty.confidence,
        lowBound: baselineUncertainty.predictedKtcLow,
        highBound: baselineUncertainty.predictedKtcHigh,
        description: baselineUncertainty.confidence === 'high'
          ? 'High confidence prediction (narrow interval)'
          : baselineUncertainty.confidence === 'medium'
            ? 'Moderate uncertainty in prediction'
            : 'High uncertainty - prediction range is wide',
      } : null,
      modelInfo: {
        type: 'pff_ensemble',
        components: ['xgboost', 'lightgbm'],
        weights: [0.4, 0.6],
        features: 148,
        pffEnhanced: true,
        modelYear,
        trainYears: modelYear === 2022 ? '2021' :
                    modelYear === 2023 ? '2021-2022' :
                    modelYear === 2024 ? '2021-2023' :
                    modelYear === 2025 ? '2021-2024' : '2021-2025',
        predictionType: 'change',  // Model predicts (end_ktc - start_ktc) instead of end_ktc
        rawModelOutput: true,  // No post-prediction bias/anchor corrections applied
        quantileModels: baselineUncertainty.intervalWidth !== null,
      },
    };

    if (historicalSeason) {
      const actualFpPerGame = historicalSeason.gamesPlayed > 0
        ? historicalSeason.fantasyPoints / historicalSeason.gamesPlayed
        : 0;

      const predictedAtActualFP = historicalSeason.predictedEndKtc;

      response.isHistorical = true;
      response.historicalYear = historicalYear;
      response.actualPerformance = {
        gamesPlayed: historicalSeason.gamesPlayed,
        fpPerGame: Math.round(actualFpPerGame * 10) / 10,
        actualEndKtc: historicalSeason.actualEndKtc,
        predictedAtActualFP,
      };
    }

    return NextResponse.json(response);
  } catch (error) {
    console.error('Error in ktc-predict API:', error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}
